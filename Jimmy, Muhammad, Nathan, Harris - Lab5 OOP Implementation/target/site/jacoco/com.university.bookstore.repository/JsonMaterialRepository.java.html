<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsonMaterialRepository.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bookstore-lab</a> &gt; <a href="index.source.html" class="el_package">com.university.bookstore.repository</a> &gt; <span class="el_source">JsonMaterialRepository.java</span></div><h1>JsonMaterialRepository.java</h1><pre class="source lang-java linenums">package com.university.bookstore.repository;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.university.bookstore.model.Material;

/**
 * JSON-based implementation of MaterialRepository (Adapter in hexagonal architecture).
 * Persists materials to a JSON file using Jackson for serialization.
 * 
 * &lt;p&gt;This adapter implements the MaterialRepository port, providing JSON file-based
 * persistence without the domain layer knowing about the storage mechanism.&lt;/p&gt;
 * 
 * @author Navid Mohaghegh
 * @version 3.0
 * @since 2024-09-15
 */
public class JsonMaterialRepository implements MaterialRepository {
    
<span class="fc" id="L27">    private static final String SAFE_BASE_DIR = System.getProperty(&quot;user.dir&quot;) + &quot;/data&quot;;</span>
    private static final int MAX_PATH_LENGTH = 255;
    
    private final String filePath;
    private final ObjectMapper objectMapper;
    private final File dataFile;
    
    /**
     * Creates a new JSON material repository.
     * 
     * @param filePath the path to the JSON file for persistence
     */
<span class="fc" id="L39">    public JsonMaterialRepository(String filePath) {</span>
        // Validate and sanitize the file path to prevent path traversal
<span class="fc" id="L41">        this.filePath = validateAndSanitizePath(filePath);</span>
<span class="fc" id="L42">        this.objectMapper = new ObjectMapper();</span>
<span class="fc" id="L43">        this.objectMapper.findAndRegisterModules();</span>
<span class="fc" id="L44">        this.dataFile = new File(this.filePath);</span>
        
        // Ensure the directory exists
<span class="fc" id="L47">        File parentDir = dataFile.getParentFile();</span>
<span class="pc bpc" id="L48" title="1 of 4 branches missed.">        if (parentDir != null &amp;&amp; !parentDir.exists()) {</span>
<span class="fc" id="L49">            parentDir.mkdirs();</span>
        }
<span class="fc" id="L51">    }</span>
    
    /**
     * Validates and sanitizes the file path to prevent path traversal attacks.
     * 
     * @param filePath the file path to validate
     * @return the validated and sanitized file path
     * @throws SecurityException if the path is invalid or attempts path traversal
     */
    private String validateAndSanitizePath(String filePath) {
<span class="fc bfc" id="L61" title="All 4 branches covered.">        if (filePath == null || filePath.trim().isEmpty()) {</span>
<span class="fc" id="L62">            throw new IllegalArgumentException(&quot;File path cannot be null or empty&quot;);</span>
        }
        
        // Check for suspicious patterns BEFORE cleaning
<span class="fc bfc" id="L66" title="All 4 branches covered.">        if (filePath.contains(&quot;../&quot;) || filePath.contains(&quot;..\\&quot;) || </span>
<span class="pc bpc" id="L67" title="2 of 4 branches missed.">            filePath.contains(&quot;%2e%2e&quot;) || filePath.contains(&quot;%252e&quot;)) {</span>
<span class="fc" id="L68">            throw new SecurityException(&quot;Invalid file path: potential path traversal detected&quot;);</span>
        }
        
        // Remove any path traversal attempts
<span class="fc" id="L72">        String cleanPath = filePath.replaceAll(&quot;\\.\\./&quot;, &quot;&quot;).replaceAll(&quot;\\.\\.&quot;, &quot;&quot;);</span>
        
        // Validate path length
<span class="fc bfc" id="L75" title="All 2 branches covered.">        if (cleanPath.length() &gt; MAX_PATH_LENGTH) {</span>
<span class="fc" id="L76">            throw new IllegalArgumentException(&quot;File path exceeds maximum length&quot;);</span>
        }
        
        try {
            // Normalize the path and ensure it's within safe directory
<span class="fc" id="L81">            Path normalizedPath = Paths.get(cleanPath).normalize();</span>
<span class="fc" id="L82">            Path safePath = Paths.get(SAFE_BASE_DIR).normalize();</span>
            
            // If the path is not absolute, make it relative to safe directory
<span class="pc bpc" id="L85" title="1 of 2 branches missed.">            if (!normalizedPath.isAbsolute()) {</span>
<span class="fc" id="L86">                normalizedPath = safePath.resolve(normalizedPath).normalize();</span>
            }
            
            // Ensure the normalized path is within the safe directory
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">            if (!normalizedPath.startsWith(safePath)) {</span>
<span class="nc" id="L91">                throw new SecurityException(&quot;File path must be within the safe directory: &quot; + SAFE_BASE_DIR);</span>
            }
            
<span class="fc" id="L94">            return normalizedPath.toString();</span>
<span class="nc" id="L95">        } catch (Exception e) {</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">            if (e instanceof SecurityException) {</span>
<span class="nc" id="L97">                throw (SecurityException) e;</span>
            }
<span class="nc" id="L99">            throw new IllegalArgumentException(&quot;Invalid file path: &quot; + e.getMessage(), e);</span>
        }
    }
    
    @Override
    public void save(Material material) {
<span class="fc bfc" id="L105" title="All 2 branches covered.">        if (material == null) {</span>
<span class="fc" id="L106">            throw new IllegalArgumentException(&quot;Material cannot be null&quot;);</span>
        }
        
        try {
<span class="fc" id="L110">            List&lt;Material&gt; materials = loadAll();</span>
            
            // Remove existing material with same ID if it exists
<span class="fc" id="L113">            materials.removeIf(m -&gt; m.getId().equals(material.getId()));</span>
            
            // Add the new/updated material
<span class="fc" id="L116">            materials.add(material);</span>
            
            // Save to file using wrapper to ensure polymorphic serialization
<span class="fc" id="L119">            MaterialsWrapper wrapper = new MaterialsWrapper(materials);</span>
<span class="fc" id="L120">            objectMapper.writerWithDefaultPrettyPrinter().writeValue(dataFile, wrapper);</span>
            
<span class="nc" id="L122">        } catch (IOException e) {</span>
<span class="nc" id="L123">            throw new RepositoryException(&quot;Failed to save material: &quot; + material.getId(), e);</span>
<span class="fc" id="L124">        }</span>
<span class="fc" id="L125">    }</span>
    
    @Override
    public Optional&lt;Material&gt; findById(String id) {
<span class="fc bfc" id="L129" title="All 4 branches covered.">        if (id == null || id.trim().isEmpty()) {</span>
<span class="fc" id="L130">            return Optional.empty();</span>
        }
        
        try {
<span class="fc" id="L134">            List&lt;Material&gt; materials = loadAll();</span>
<span class="fc" id="L135">            return materials.stream()</span>
<span class="fc" id="L136">                .filter(m -&gt; id.equals(m.getId()))</span>
<span class="fc" id="L137">                .findFirst();</span>
                
<span class="nc" id="L139">        } catch (IOException e) {</span>
<span class="nc" id="L140">            throw new RepositoryException(&quot;Failed to find material by ID: &quot; + id, e);</span>
        }
    }
    
    @Override
    public List&lt;Material&gt; findAll() {
        try {
<span class="fc" id="L147">            return loadAll();</span>
<span class="nc" id="L148">        } catch (IOException e) {</span>
<span class="nc" id="L149">            throw new RepositoryException(&quot;Failed to load all materials&quot;, e);</span>
        }
    }
    
    @Override
    public boolean delete(String id) {
<span class="fc bfc" id="L155" title="All 4 branches covered.">        if (id == null || id.trim().isEmpty()) {</span>
<span class="fc" id="L156">            return false;</span>
        }
        
        try {
<span class="fc" id="L160">            List&lt;Material&gt; materials = loadAll();</span>
<span class="fc" id="L161">            boolean removed = materials.removeIf(m -&gt; id.equals(m.getId()));</span>
            
<span class="fc bfc" id="L163" title="All 2 branches covered.">            if (removed) {</span>
<span class="fc" id="L164">                MaterialsWrapper wrapper = new MaterialsWrapper(materials);</span>
<span class="fc" id="L165">                objectMapper.writerWithDefaultPrettyPrinter().writeValue(dataFile, wrapper);</span>
            }
            
<span class="fc" id="L168">            return removed;</span>
            
<span class="nc" id="L170">        } catch (IOException e) {</span>
<span class="nc" id="L171">            throw new RepositoryException(&quot;Failed to delete material: &quot; + id, e);</span>
        }
    }
    
    @Override
    public boolean exists(String id) {
<span class="fc" id="L177">        return findById(id).isPresent();</span>
    }
    
    @Override
    public long count() {
        try {
<span class="fc" id="L183">            return loadAll().size();</span>
<span class="nc" id="L184">        } catch (IOException e) {</span>
<span class="nc" id="L185">            throw new RepositoryException(&quot;Failed to count materials&quot;, e);</span>
        }
    }
    
    @Override
    public void deleteAll() {
        try {
<span class="fc" id="L192">            MaterialsWrapper wrapper = new MaterialsWrapper(new ArrayList&lt;Material&gt;());</span>
<span class="fc" id="L193">            objectMapper.writerWithDefaultPrettyPrinter().writeValue(dataFile, wrapper);</span>
<span class="nc" id="L194">        } catch (IOException e) {</span>
<span class="nc" id="L195">            throw new RepositoryException(&quot;Failed to clear all materials&quot;, e);</span>
<span class="fc" id="L196">        }</span>
<span class="fc" id="L197">    }</span>
    
    /**
     * Loads all materials from the JSON file.
     * 
     * @return list of materials
     * @throws IOException if file reading fails
     */
    private List&lt;Material&gt; loadAll() throws IOException {
<span class="fc bfc" id="L206" title="All 2 branches covered.">        if (!dataFile.exists()) {</span>
<span class="fc" id="L207">            return new ArrayList&lt;&gt;();</span>
        }
        
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">        if (dataFile.length() == 0) {</span>
<span class="nc" id="L211">            return new ArrayList&lt;&gt;();</span>
        }
        
        try {
<span class="fc" id="L215">            MaterialsWrapper wrapper = objectMapper.readValue(dataFile, MaterialsWrapper.class);</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">            return wrapper.getMaterials() != null ? wrapper.getMaterials() : new ArrayList&lt;&gt;();</span>
<span class="nc" id="L217">        } catch (IOException e) {</span>
            // Log the error for debugging
<span class="nc" id="L219">            System.err.println(&quot;Failed to load materials from &quot; + dataFile + &quot;: &quot; + e.getMessage());</span>
            // If JSON parsing fails, return empty list
<span class="nc" id="L221">            return new ArrayList&lt;&gt;();</span>
        }
    }
    
    /**
     * Gets the file path used for persistence.
     * 
     * @return the file path
     */
    public String getFilePath() {
<span class="fc" id="L231">        return filePath;</span>
    }
    
    /**
     * Checks if the data file exists.
     * 
     * @return true if the file exists
     */
    public boolean dataFileExists() {
<span class="fc" id="L240">        return dataFile.exists();</span>
    }
    
    /**
     * Gets the size of the data file in bytes.
     * 
     * @return file size in bytes
     */
    public long getDataFileSize() {
<span class="fc" id="L249">        return dataFile.length();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>