<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ModernConcurrentMaterialStore.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bookstore-lab</a> &gt; <a href="index.source.html" class="el_package">com.university.bookstore.impl</a> &gt; <span class="el_source">ModernConcurrentMaterialStore.java</span></div><h1>ModernConcurrentMaterialStore.java</h1><pre class="source lang-java linenums">package com.university.bookstore.impl;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.locks.StampedLock;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.university.bookstore.api.MaterialStore;
import com.university.bookstore.model.Magazine;
import com.university.bookstore.model.Material;
import com.university.bookstore.model.Media;
import com.university.bookstore.model.PrintedBook;

/**
 * Modern thread-safe implementation of MaterialStore using best practices.
 * Features:
 * - StampedLock for optimized read performance
 * - ExecutorService for async operations
 * - CompletableFuture for non-blocking operations
 * - Proper resource management with AutoCloseable
 * - Virtual thread support (when available)
 * 
 * @author Navid Mohaghegh
 * @version 4.0
 * @since 2024-09-15
 */
public class ModernConcurrentMaterialStore implements MaterialStore, AutoCloseable {
    
<span class="fc" id="L33">    private static final Logger LOGGER = LoggerFactory.getLogger(ModernConcurrentMaterialStore.class);</span>
    
    private final Map&lt;String, Material&gt; materials;
    private final StampedLock stampedLock;
    private final ExecutorService executorService;
    private final ScheduledExecutorService scheduledExecutor;
<span class="fc" id="L39">    private volatile boolean closed = false;</span>
    
    /**
     * Creates a new modern thread-safe material store.
     */
<span class="fc" id="L44">    public ModernConcurrentMaterialStore() {</span>
<span class="fc" id="L45">        this.materials = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L46">        this.stampedLock = new StampedLock();</span>
        
        // Use ForkJoinPool for better work-stealing behavior
<span class="fc" id="L49">        this.executorService = new ForkJoinPool(</span>
<span class="fc" id="L50">            Runtime.getRuntime().availableProcessors(),</span>
            ForkJoinPool.defaultForkJoinWorkerThreadFactory,
            null, 
            true // Enable async mode for better throughput
        );
        
<span class="fc" id="L56">        this.scheduledExecutor = Executors.newScheduledThreadPool(2, r -&gt; {</span>
<span class="fc" id="L57">            Thread t = new Thread(r, &quot;MaterialStore-Scheduler&quot;);</span>
<span class="fc" id="L58">            t.setDaemon(true);</span>
<span class="fc" id="L59">            return t;</span>
        });
        
        // Schedule periodic cleanup tasks
<span class="fc" id="L63">        scheduleMaintenanceTasks();</span>
<span class="fc" id="L64">    }</span>
    
    /**
     * Creates a material store with initial materials.
     * 
     * @param initialMaterials materials to add initially
     */
    public ModernConcurrentMaterialStore(Collection&lt;Material&gt; initialMaterials) {
<span class="nc" id="L72">        this();</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">        if (initialMaterials != null) {</span>
            // Parallel addition for better performance
<span class="nc" id="L75">            initialMaterials.parallelStream().forEach(this::addMaterial);</span>
        }
<span class="nc" id="L77">    }</span>
    
    private void scheduleMaintenanceTasks() {
        // Example: periodic cache cleanup or metrics collection
<span class="fc" id="L81">        scheduledExecutor.scheduleAtFixedRate(</span>
            this::performMaintenance, 
            1, 1, TimeUnit.HOURS
        );
<span class="fc" id="L85">    }</span>
    
    private void performMaintenance() {
<span class="nc bnc" id="L88" title="All 2 branches missed.">        if (!closed) {</span>
            // Maintenance tasks like clearing old data, collecting metrics, etc.
            // This is a placeholder for actual maintenance logic
        }
<span class="nc" id="L92">    }</span>
    
    @Override
    public boolean addMaterial(Material material) {
<span class="fc" id="L96">        Objects.requireNonNull(material, &quot;Material cannot be null&quot;);</span>
<span class="fc" id="L97">        ensureNotClosed();</span>
        
<span class="fc" id="L99">        long stamp = stampedLock.writeLock();</span>
        try {
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">            return materials.putIfAbsent(material.getId(), material) == null;</span>
        } finally {
<span class="fc" id="L103">            stampedLock.unlockWrite(stamp);</span>
        }
    }
    
    /**
     * Adds material asynchronously.
     * 
     * @param material the material to add
     * @return CompletableFuture with the result
     */
    public CompletableFuture&lt;Boolean&gt; addMaterialAsync(Material material) {
<span class="fc" id="L114">        return CompletableFuture.supplyAsync(</span>
<span class="fc" id="L115">            () -&gt; addMaterial(material), </span>
            executorService
        );
    }
    
    /**
     * Adds multiple materials in batch asynchronously.
     * 
     * @param materials collection of materials to add
     * @return CompletableFuture with results map
     */
    public CompletableFuture&lt;Map&lt;String, Boolean&gt;&gt; addMaterialsBatchAsync(Collection&lt;Material&gt; materials) {
<span class="fc" id="L127">        List&lt;CompletableFuture&lt;Map.Entry&lt;String, Boolean&gt;&gt;&gt; futures = materials.stream()</span>
<span class="fc" id="L128">            .map(material -&gt; CompletableFuture.supplyAsync(</span>
<span class="fc" id="L129">                () -&gt; Map.entry(material.getId(), addMaterial(material)),</span>
                executorService
            ))
<span class="fc" id="L132">            .toList();</span>
        
<span class="fc" id="L134">        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))</span>
<span class="fc" id="L135">            .thenApply(v -&gt; futures.stream()</span>
<span class="fc" id="L136">                .map(CompletableFuture::join)</span>
<span class="fc" id="L137">                .collect(Collectors.toMap(</span>
                    Map.Entry::getKey,
                    Map.Entry::getValue
                )));
    }
    
    @Override
    public Optional&lt;Material&gt; removeMaterial(String id) {
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">        if (id == null) {</span>
<span class="nc" id="L146">            return Optional.empty();</span>
        }
<span class="fc" id="L148">        ensureNotClosed();</span>
        
<span class="fc" id="L150">        long stamp = stampedLock.writeLock();</span>
        try {
<span class="fc" id="L152">            return Optional.ofNullable(materials.remove(id));</span>
        } finally {
<span class="fc" id="L154">            stampedLock.unlockWrite(stamp);</span>
        }
    }
    
    @Override
    public Optional&lt;Material&gt; findById(String id) {
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        if (id == null) {</span>
<span class="nc" id="L161">            return Optional.empty();</span>
        }
<span class="fc" id="L163">        ensureNotClosed();</span>
        
        // Try optimistic read first for better performance
<span class="fc" id="L166">        long stamp = stampedLock.tryOptimisticRead();</span>
<span class="fc" id="L167">        Material material = materials.get(id);</span>
        
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (!stampedLock.validate(stamp)) {</span>
            // Optimistic read failed, acquire read lock
<span class="fc" id="L171">            stamp = stampedLock.readLock();</span>
            try {
<span class="fc" id="L173">                material = materials.get(id);</span>
            } finally {
<span class="fc" id="L175">                stampedLock.unlockRead(stamp);</span>
            }
        }
        
<span class="fc" id="L179">        return Optional.ofNullable(material);</span>
    }
    
    /**
     * Finds material by ID asynchronously.
     * 
     * @param id the material ID
     * @return CompletableFuture with the result
     */
    public CompletableFuture&lt;Optional&lt;Material&gt;&gt; findByIdAsync(String id) {
<span class="fc" id="L189">        return CompletableFuture.supplyAsync(</span>
<span class="fc" id="L190">            () -&gt; findById(id), </span>
            executorService
        );
    }
    
    /**
     * Finds multiple materials by IDs asynchronously.
     * 
     * @param ids list of material IDs
     * @return CompletableFuture with results map
     */
    public CompletableFuture&lt;Map&lt;String, Material&gt;&gt; findByIdsAsync(List&lt;String&gt; ids) {
<span class="fc" id="L202">        List&lt;CompletableFuture&lt;Map.Entry&lt;String, Optional&lt;Material&gt;&gt;&gt;&gt; futures = ids.stream()</span>
<span class="fc" id="L203">            .map(id -&gt; CompletableFuture.supplyAsync(</span>
<span class="fc" id="L204">                () -&gt; Map.entry(id, findById(id)),</span>
                executorService
            ))
<span class="fc" id="L207">            .toList();</span>
        
<span class="fc" id="L209">        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))</span>
<span class="fc" id="L210">            .thenApply(v -&gt; futures.stream()</span>
<span class="fc" id="L211">                .map(CompletableFuture::join)</span>
<span class="fc" id="L212">                .filter(entry -&gt; entry.getValue().isPresent())</span>
<span class="fc" id="L213">                .collect(Collectors.toMap(</span>
                    Map.Entry::getKey,
<span class="fc" id="L215">                    entry -&gt; entry.getValue().get()</span>
                )));
    }
    
    @Override
    public List&lt;Material&gt; searchByTitle(String title) {
<span class="pc bpc" id="L221" title="2 of 4 branches missed.">        if (title == null || title.trim().isEmpty()) {</span>
<span class="nc" id="L222">            return new ArrayList&lt;&gt;();</span>
        }
<span class="fc" id="L224">        ensureNotClosed();</span>
        
<span class="fc" id="L226">        String searchTerm = title.toLowerCase().trim();</span>
<span class="fc" id="L227">        long stamp = stampedLock.readLock();</span>
        try {
<span class="fc" id="L229">            return materials.values().parallelStream()</span>
<span class="fc" id="L230">                .filter(m -&gt; m.getTitle().toLowerCase().contains(searchTerm))</span>
<span class="fc" id="L231">                .collect(Collectors.toList());</span>
        } finally {
<span class="fc" id="L233">            stampedLock.unlockRead(stamp);</span>
        }
    }
    
    /**
     * Searches by title asynchronously.
     * 
     * @param title the title to search for
     * @return CompletableFuture with the results
     */
    public CompletableFuture&lt;List&lt;Material&gt;&gt; searchByTitleAsync(String title) {
<span class="fc" id="L244">        return CompletableFuture.supplyAsync(</span>
<span class="fc" id="L245">            () -&gt; searchByTitle(title), </span>
            executorService
        );
    }
    
    @Override
    public List&lt;Material&gt; searchByCreator(String creator) {
<span class="pc bpc" id="L252" title="2 of 4 branches missed.">        if (creator == null || creator.trim().isEmpty()) {</span>
<span class="nc" id="L253">            return new ArrayList&lt;&gt;();</span>
        }
<span class="fc" id="L255">        ensureNotClosed();</span>
        
<span class="fc" id="L257">        String searchTerm = creator.toLowerCase().trim();</span>
<span class="fc" id="L258">        long stamp = stampedLock.readLock();</span>
        try {
<span class="fc" id="L260">            return materials.values().parallelStream()</span>
<span class="fc" id="L261">                .filter(m -&gt; m.getCreator().toLowerCase().contains(searchTerm))</span>
<span class="fc" id="L262">                .collect(Collectors.toList());</span>
        } finally {
<span class="fc" id="L264">            stampedLock.unlockRead(stamp);</span>
        }
    }
    
    @Override
    public List&lt;Material&gt; getMaterialsByType(Material.MaterialType type) {
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        if (type == null) {</span>
<span class="nc" id="L271">            return new ArrayList&lt;&gt;();</span>
        }
<span class="fc" id="L273">        ensureNotClosed();</span>
        
<span class="fc" id="L275">        long stamp = stampedLock.readLock();</span>
        try {
<span class="fc" id="L277">            return materials.values().parallelStream()</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">                .filter(m -&gt; m.getType() == type)</span>
<span class="fc" id="L279">                .collect(Collectors.toList());</span>
        } finally {
<span class="fc" id="L281">            stampedLock.unlockRead(stamp);</span>
        }
    }
    
    @Override
    public List&lt;Media&gt; getMediaMaterials() {
<span class="nc" id="L287">        ensureNotClosed();</span>
        
<span class="nc" id="L289">        long stamp = stampedLock.readLock();</span>
        try {
<span class="nc" id="L291">            return materials.values().parallelStream()</span>
<span class="nc" id="L292">                .filter(Media.class::isInstance)</span>
<span class="nc" id="L293">                .map(Media.class::cast)</span>
<span class="nc" id="L294">                .collect(Collectors.toList());</span>
        } finally {
<span class="nc" id="L296">            stampedLock.unlockRead(stamp);</span>
        }
    }
    
    @Override
    public List&lt;Material&gt; filterMaterials(Predicate&lt;Material&gt; predicate) {
<span class="nc" id="L302">        Objects.requireNonNull(predicate, &quot;Predicate cannot be null&quot;);</span>
<span class="nc" id="L303">        ensureNotClosed();</span>
        
<span class="nc" id="L305">        long stamp = stampedLock.readLock();</span>
        try {
<span class="nc" id="L307">            return materials.values().parallelStream()</span>
<span class="nc" id="L308">                .filter(predicate)</span>
<span class="nc" id="L309">                .collect(Collectors.toList());</span>
        } finally {
<span class="nc" id="L311">            stampedLock.unlockRead(stamp);</span>
        }
    }
    
    @Override
    public List&lt;Material&gt; getMaterialsByPriceRange(double minPrice, double maxPrice) {
<span class="pc bpc" id="L317" title="3 of 6 branches missed.">        if (minPrice &lt; 0 || maxPrice &lt; 0 || minPrice &gt; maxPrice) {</span>
<span class="nc" id="L318">            return new ArrayList&lt;&gt;();</span>
        }
<span class="fc" id="L320">        ensureNotClosed();</span>
        
<span class="fc" id="L322">        long stamp = stampedLock.readLock();</span>
        try {
<span class="fc" id="L324">            return materials.values().parallelStream()</span>
<span class="pc bpc" id="L325" title="2 of 4 branches missed.">                .filter(m -&gt; m.getPrice() &gt;= minPrice &amp;&amp; m.getPrice() &lt;= maxPrice)</span>
<span class="fc" id="L326">                .collect(Collectors.toList());</span>
        } finally {
<span class="fc" id="L328">            stampedLock.unlockRead(stamp);</span>
        }
    }
    
    @Override
    public List&lt;Material&gt; getMaterialsByYear(int year) {
<span class="nc" id="L334">        ensureNotClosed();</span>
        
<span class="nc" id="L336">        long stamp = stampedLock.readLock();</span>
        try {
<span class="nc" id="L338">            return materials.values().parallelStream()</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">                .filter(m -&gt; m.getYear() == year)</span>
<span class="nc" id="L340">                .collect(Collectors.toList());</span>
        } finally {
<span class="nc" id="L342">            stampedLock.unlockRead(stamp);</span>
        }
    }
    
    @Override
    public List&lt;Material&gt; getAllMaterialsSorted() {
<span class="nc" id="L348">        ensureNotClosed();</span>
        
<span class="nc" id="L350">        long stamp = stampedLock.readLock();</span>
        try {
<span class="nc" id="L352">            return materials.values().stream()</span>
<span class="nc" id="L353">                .sorted()</span>
<span class="nc" id="L354">                .collect(Collectors.toList());</span>
        } finally {
<span class="nc" id="L356">            stampedLock.unlockRead(stamp);</span>
        }
    }
    
    @Override
    public List&lt;Material&gt; getAllMaterials() {
<span class="fc" id="L362">        ensureNotClosed();</span>
        
        // Use optimistic read for better performance
<span class="fc" id="L365">        long stamp = stampedLock.tryOptimisticRead();</span>
<span class="fc" id="L366">        List&lt;Material&gt; result = new ArrayList&lt;&gt;(materials.values());</span>
        
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">        if (!stampedLock.validate(stamp)) {</span>
<span class="nc" id="L369">            stamp = stampedLock.readLock();</span>
            try {
<span class="nc" id="L371">                result = new ArrayList&lt;&gt;(materials.values());</span>
            } finally {
<span class="nc" id="L373">                stampedLock.unlockRead(stamp);</span>
            }
        }
        
<span class="fc" id="L377">        return result;</span>
    }
    
    @Override
    public double getTotalInventoryValue() {
<span class="fc" id="L382">        ensureNotClosed();</span>
        
<span class="fc" id="L384">        long stamp = stampedLock.readLock();</span>
        try {
<span class="fc" id="L386">            return materials.values().parallelStream()</span>
<span class="fc" id="L387">                .mapToDouble(Material::getPrice)</span>
<span class="fc" id="L388">                .sum();</span>
        } finally {
<span class="fc" id="L390">            stampedLock.unlockRead(stamp);</span>
        }
    }
    
    /**
     * Gets total inventory value asynchronously.
     * 
     * @return CompletableFuture with the total value
     */
    public CompletableFuture&lt;Double&gt; getTotalInventoryValueAsync() {
<span class="fc" id="L400">        return CompletableFuture.supplyAsync(</span>
            this::getTotalInventoryValue, 
            executorService
        );
    }
    
    @Override
    public double getTotalDiscountedValue() {
<span class="nc" id="L408">        ensureNotClosed();</span>
        
<span class="nc" id="L410">        long stamp = stampedLock.readLock();</span>
        try {
<span class="nc" id="L412">            return materials.values().parallelStream()</span>
<span class="nc" id="L413">                .mapToDouble(Material::getDiscountedPrice)</span>
<span class="nc" id="L414">                .sum();</span>
        } finally {
<span class="nc" id="L416">            stampedLock.unlockRead(stamp);</span>
        }
    }
    
    @Override
    public InventoryStats getInventoryStats() {
<span class="fc" id="L422">        ensureNotClosed();</span>
        
<span class="fc" id="L424">        long stamp = stampedLock.readLock();</span>
        try {
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">            if (materials.isEmpty()) {</span>
<span class="nc" id="L427">                return new InventoryStats(0, 0, 0, 0, 0, 0);</span>
            }
            
<span class="fc" id="L430">            List&lt;Double&gt; prices = materials.values().stream()</span>
<span class="fc" id="L431">                .map(Material::getPrice)</span>
<span class="fc" id="L432">                .sorted()</span>
<span class="fc" id="L433">                .collect(Collectors.toList());</span>
            
<span class="fc" id="L435">            double averagePrice = prices.stream()</span>
<span class="fc" id="L436">                .mapToDouble(Double::doubleValue)</span>
<span class="fc" id="L437">                .average()</span>
<span class="fc" id="L438">                .orElse(0.0);</span>
            
<span class="fc bfc" id="L440" title="All 2 branches covered.">            double medianPrice = prices.size() % 2 == 0</span>
<span class="fc" id="L441">                ? (prices.get(prices.size() / 2 - 1) + prices.get(prices.size() / 2)) / 2</span>
<span class="fc" id="L442">                : prices.get(prices.size() / 2);</span>
            
<span class="fc" id="L444">            int uniqueTypes = (int) materials.values().stream()</span>
<span class="fc" id="L445">                .map(Material::getType)</span>
<span class="fc" id="L446">                .distinct()</span>
<span class="fc" id="L447">                .count();</span>
            
<span class="fc" id="L449">            int mediaCount = (int) materials.values().stream()</span>
<span class="fc" id="L450">                .filter(Media.class::isInstance)</span>
<span class="fc" id="L451">                .count();</span>
            
<span class="fc" id="L453">            int printCount = (int) materials.values().stream()</span>
<span class="pc bpc" id="L454" title="1 of 4 branches missed.">                .filter(m -&gt; m instanceof PrintedBook || m instanceof Magazine)</span>
<span class="fc" id="L455">                .count();</span>
            
<span class="fc" id="L457">            return new InventoryStats(</span>
<span class="fc" id="L458">                materials.size(),</span>
                averagePrice,
                medianPrice,
                uniqueTypes,
                mediaCount,
                printCount
            );
        } finally {
<span class="fc" id="L466">            stampedLock.unlockRead(stamp);</span>
        }
    }
    
    /**
     * Gets inventory statistics asynchronously.
     * 
     * @return CompletableFuture with the statistics
     */
    public CompletableFuture&lt;InventoryStats&gt; getInventoryStatsAsync() {
<span class="fc" id="L476">        return CompletableFuture.supplyAsync(</span>
            this::getInventoryStats, 
            executorService
        );
    }
    
    @Override
    public void clearInventory() {
<span class="nc" id="L484">        ensureNotClosed();</span>
        
<span class="nc" id="L486">        long stamp = stampedLock.writeLock();</span>
        try {
<span class="nc" id="L488">            materials.clear();</span>
        } finally {
<span class="nc" id="L490">            stampedLock.unlockWrite(stamp);</span>
        }
<span class="nc" id="L492">    }</span>
    
    @Override
    public int size() {
<span class="fc" id="L496">        ensureNotClosed();</span>
        
        // Use optimistic read for size check
<span class="fc" id="L499">        long stamp = stampedLock.tryOptimisticRead();</span>
<span class="fc" id="L500">        int size = materials.size();</span>
        
<span class="pc bpc" id="L502" title="1 of 2 branches missed.">        if (!stampedLock.validate(stamp)) {</span>
<span class="nc" id="L503">            stamp = stampedLock.readLock();</span>
            try {
<span class="nc" id="L505">                size = materials.size();</span>
            } finally {
<span class="nc" id="L507">                stampedLock.unlockRead(stamp);</span>
            }
        }
        
<span class="fc" id="L511">        return size;</span>
    }
    
    @Override
    public boolean isEmpty() {
<span class="nc bnc" id="L516" title="All 2 branches missed.">        return size() == 0;</span>
    }
    
    @Override
    public List&lt;Material&gt; findRecentMaterials(int years) {
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">        if (years &lt; 0) {</span>
<span class="nc" id="L522">            throw new IllegalArgumentException(&quot;Years cannot be negative: &quot; + years);</span>
        }
<span class="fc" id="L524">        ensureNotClosed();</span>
        
<span class="fc" id="L526">        int currentYear = java.time.Year.now().getValue();</span>
<span class="fc" id="L527">        int cutoffYear = currentYear - years;</span>
        
<span class="fc" id="L529">        long stamp = stampedLock.readLock();</span>
        try {
<span class="fc" id="L531">            return materials.values().parallelStream()</span>
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">                .filter(material -&gt; material.getYear() &gt;= cutoffYear)</span>
<span class="fc" id="L533">                .collect(Collectors.toList());</span>
        } finally {
<span class="fc" id="L535">            stampedLock.unlockRead(stamp);</span>
        }
    }
    
    @Override
    public List&lt;Material&gt; findByCreators(String... creators) {
<span class="nc bnc" id="L541" title="All 4 branches missed.">        if (creators == null || creators.length == 0) {</span>
<span class="nc" id="L542">            return new ArrayList&lt;&gt;();</span>
        }
<span class="nc" id="L544">        ensureNotClosed();</span>
        
<span class="nc" id="L546">        Set&lt;String&gt; creatorSet = Arrays.stream(creators)</span>
<span class="nc" id="L547">            .filter(Objects::nonNull)</span>
<span class="nc" id="L548">            .map(String::trim)</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">            .filter(s -&gt; !s.isEmpty())</span>
<span class="nc" id="L550">            .collect(Collectors.toSet());</span>
        
<span class="nc bnc" id="L552" title="All 2 branches missed.">        if (creatorSet.isEmpty()) {</span>
<span class="nc" id="L553">            return new ArrayList&lt;&gt;();</span>
        }
        
<span class="nc" id="L556">        long stamp = stampedLock.readLock();</span>
        try {
<span class="nc" id="L558">            return materials.values().parallelStream()</span>
<span class="nc" id="L559">                .filter(material -&gt; creatorSet.contains(material.getCreator()))</span>
<span class="nc" id="L560">                .collect(Collectors.toList());</span>
        } finally {
<span class="nc" id="L562">            stampedLock.unlockRead(stamp);</span>
        }
    }
    
    @Override
    public List&lt;Material&gt; findWithPredicate(Predicate&lt;Material&gt; condition) {
<span class="nc" id="L568">        Objects.requireNonNull(condition, &quot;Predicate cannot be null&quot;);</span>
<span class="nc" id="L569">        ensureNotClosed();</span>
        
<span class="nc" id="L571">        long stamp = stampedLock.readLock();</span>
        try {
<span class="nc" id="L573">            return materials.values().parallelStream()</span>
<span class="nc" id="L574">                .filter(condition)</span>
<span class="nc" id="L575">                .collect(Collectors.toList());</span>
        } finally {
<span class="nc" id="L577">            stampedLock.unlockRead(stamp);</span>
        }
    }
    
    @Override
    public List&lt;Material&gt; getSorted(Comparator&lt;Material&gt; comparator) {
<span class="nc" id="L583">        Objects.requireNonNull(comparator, &quot;Comparator cannot be null&quot;);</span>
<span class="nc" id="L584">        ensureNotClosed();</span>
        
<span class="nc" id="L586">        long stamp = stampedLock.readLock();</span>
        try {
<span class="nc" id="L588">            return materials.values().stream()</span>
<span class="nc" id="L589">                .sorted(comparator)</span>
<span class="nc" id="L590">                .collect(Collectors.toList());</span>
        } finally {
<span class="nc" id="L592">            stampedLock.unlockRead(stamp);</span>
        }
    }
    
    /**
     * Performs parallel search across multiple criteria.
     * 
     * @param title optional title search term
     * @param creator optional creator search term
     * @param type optional material type
     * @return CompletableFuture with combined results
     */
    public CompletableFuture&lt;List&lt;Material&gt;&gt; parallelSearchAsync(
            String title, String creator, Material.MaterialType type) {
        
<span class="fc" id="L607">        List&lt;CompletableFuture&lt;List&lt;Material&gt;&gt;&gt; searches = new ArrayList&lt;&gt;();</span>
        
<span class="pc bpc" id="L609" title="2 of 4 branches missed.">        if (title != null &amp;&amp; !title.trim().isEmpty()) {</span>
<span class="fc" id="L610">            searches.add(searchByTitleAsync(title));</span>
        }
<span class="pc bpc" id="L612" title="2 of 4 branches missed.">        if (creator != null &amp;&amp; !creator.trim().isEmpty()) {</span>
<span class="fc" id="L613">            searches.add(CompletableFuture.supplyAsync(</span>
<span class="fc" id="L614">                () -&gt; searchByCreator(creator), executorService));</span>
        }
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">        if (type != null) {</span>
<span class="fc" id="L617">            searches.add(CompletableFuture.supplyAsync(</span>
<span class="fc" id="L618">                () -&gt; getMaterialsByType(type), executorService));</span>
        }
        
<span class="pc bpc" id="L621" title="1 of 2 branches missed.">        if (searches.isEmpty()) {</span>
<span class="nc" id="L622">            return CompletableFuture.completedFuture(new ArrayList&lt;&gt;());</span>
        }
        
<span class="fc" id="L625">        return CompletableFuture.allOf(searches.toArray(new CompletableFuture[0]))</span>
<span class="fc" id="L626">            .thenApply(v -&gt; searches.stream()</span>
<span class="fc" id="L627">                .map(CompletableFuture::join)</span>
<span class="fc" id="L628">                .flatMap(List::stream)</span>
<span class="fc" id="L629">                .distinct()</span>
<span class="fc" id="L630">                .collect(Collectors.toList()));</span>
    }
    
    /**
     * Groups materials by type for reporting.
     * 
     * @return map of type to materials
     */
    public Map&lt;Material.MaterialType, List&lt;Material&gt;&gt; groupByType() {
<span class="nc" id="L639">        ensureNotClosed();</span>
        
<span class="nc" id="L641">        long stamp = stampedLock.readLock();</span>
        try {
<span class="nc" id="L643">            return materials.values().stream()</span>
<span class="nc" id="L644">                .collect(Collectors.groupingBy(Material::getType));</span>
        } finally {
<span class="nc" id="L646">            stampedLock.unlockRead(stamp);</span>
        }
    }
    
    /**
     * Gets materials with active discounts.
     * 
     * @return list of discounted materials
     */
    public List&lt;Material&gt; getDiscountedMaterials() {
<span class="nc" id="L656">        ensureNotClosed();</span>
        
<span class="nc" id="L658">        long stamp = stampedLock.readLock();</span>
        try {
<span class="nc" id="L660">            return materials.values().parallelStream()</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">                .filter(m -&gt; m.getDiscountRate() &gt; 0)</span>
<span class="nc" id="L662">                .collect(Collectors.toList());</span>
        } finally {
<span class="nc" id="L664">            stampedLock.unlockRead(stamp);</span>
        }
    }
    
    /**
     * Calculates total savings from discounts.
     * 
     * @return total discount amount
     */
    public double getTotalDiscountAmount() {
<span class="nc" id="L674">        ensureNotClosed();</span>
        
<span class="nc" id="L676">        long stamp = stampedLock.readLock();</span>
        try {
<span class="nc" id="L678">            return materials.values().parallelStream()</span>
<span class="nc" id="L679">                .mapToDouble(m -&gt; m.getPrice() * m.getDiscountRate())</span>
<span class="nc" id="L680">                .sum();</span>
        } finally {
<span class="nc" id="L682">            stampedLock.unlockRead(stamp);</span>
        }
    }
    
    private void ensureNotClosed() {
<span class="fc bfc" id="L687" title="All 2 branches covered.">        if (closed) {</span>
<span class="fc" id="L688">            throw new IllegalStateException(&quot;MaterialStore has been closed&quot;);</span>
        }
<span class="fc" id="L690">    }</span>
    
    @Override
    public void close() {
<span class="pc bpc" id="L694" title="1 of 2 branches missed.">        if (!closed) {</span>
<span class="fc" id="L695">            closed = true;</span>
            
            // Shutdown executors gracefully
<span class="fc" id="L698">            executorService.shutdown();</span>
<span class="fc" id="L699">            scheduledExecutor.shutdown();</span>
            
            try {
                // Wait for existing tasks to complete
<span class="pc bpc" id="L703" title="1 of 2 branches missed.">                if (!executorService.awaitTermination(10, TimeUnit.SECONDS)) {</span>
<span class="nc" id="L704">                    executorService.shutdownNow();</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">                    if (!executorService.awaitTermination(5, TimeUnit.SECONDS)) {</span>
<span class="nc" id="L706">                        LOGGER.error(&quot;ExecutorService did not terminate within timeout&quot;);</span>
                    }
                }
                
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">                if (!scheduledExecutor.awaitTermination(5, TimeUnit.SECONDS)) {</span>
<span class="nc" id="L711">                    scheduledExecutor.shutdownNow();</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">                    if (!scheduledExecutor.awaitTermination(5, TimeUnit.SECONDS)) {</span>
<span class="nc" id="L713">                        LOGGER.error(&quot;ScheduledExecutor did not terminate within timeout&quot;);</span>
                    }
                }
<span class="nc" id="L716">            } catch (InterruptedException e) {</span>
<span class="nc" id="L717">                executorService.shutdownNow();</span>
<span class="nc" id="L718">                scheduledExecutor.shutdownNow();</span>
<span class="nc" id="L719">                Thread.currentThread().interrupt();</span>
<span class="fc" id="L720">            }</span>
        }
<span class="fc" id="L722">    }</span>
    
    @Override
    public String toString() {
<span class="nc" id="L726">        ensureNotClosed();</span>
        
<span class="nc" id="L728">        long stamp = stampedLock.readLock();</span>
        try {
<span class="nc" id="L730">            return String.format(&quot;ModernConcurrentMaterialStore[Size=%d, Types=%d, Value=$%.2f]&quot;,</span>
<span class="nc" id="L731">                size(),</span>
<span class="nc" id="L732">                groupByType().size(),</span>
<span class="nc" id="L733">                getTotalInventoryValue());</span>
        } finally {
<span class="nc" id="L735">            stampedLock.unlockRead(stamp);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>